---
layout: post
title: 高并发情况下的网络流量控制算法
datetime: 2019-01-27 22:02:32
description: 高并发情况下的网络流量控制算法
comments: true
tags:
 - 算法
categories:
 - 算法
---



在线服务在高并发场景或者用户请求/流量突然暴增的场景下，经常会造成系统崩溃。大部分服务都需要在上线前进行压力测试，性能测试来保证服务能够抗住突然的流量陡增。而对于服务质量本身，业界常用的技术手段就是`用户限流`和`请求限频`：当用户请求达到一定并发数或频率时，对后续的请求进行排队、等待、降级或者拒绝服务等操作。在限流场景下，常用的流量控制算法是：漏桶算法和令牌桶算法。

<!-- more -->

## 漏桶算法（Leaky Bucket）

漏桶算法的主要思想是控制数据注入到网络的速率，平滑处理网络中突增的流量。漏桶算法能够将突增流量整形，为网络提供一个稳定的流量输出。

漏桶算法示意图如下所示（来自网络）：

![](/images/posts/flow_control_algorithms/leaky_bucket.png)

水（请求）先进入到漏桶中，漏桶以一定的速率出水（接口/服务响应速率）。当水流入速度过大会直接溢出（访问频率大于接口响应速率），拒绝为水（请求）提供服务，直接抛弃。漏桶算法强行限制了数据的传输速率。

> 算法核心：缓存请求、匀速处理请求，多余的请求直接丢弃。



## 令牌桶算法（Token Bucket）

网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常用的一种算法。典型情况下，令牌桶算法用来控制发送到网络中的数据的数目，并允许突发数据的处理和发送。

令牌桶算法示意图如下所示（来自网络）：

![](/images/posts/flow_control_algorithms/token_bucket.png)

令牌桶算法拥有一个固定大小的令牌桶，其可以自行以恒定的速率源源不断地产生令牌。如果令牌不被消耗或者被消耗的速率小于令牌产生的速率。令牌会不断增多，直到把令牌桶填满。后面产生的令牌就会从桶中溢出。最大令牌数即为桶的容量大小。

### 算法主要思想

1. 令牌以固定速率产生，并缓存在令牌桶中（若QPS为100，则每10ms产生一个令牌）
2. 令牌桶放满后，多余的令牌将会被丢弃
3. 请求要消耗等比例的令牌才能被处理
4. 令牌不够时，请求将会被缓存、阻塞处理或者拒绝服务



只要令牌桶中还有令牌，那么就允许突发的传输数据拿到令牌，并未突发请求提供服务。直到达到用户配置的上限。所以令牌桶算法运用于具有突发特性的流量。



> 算法优势：可以方便的改变速率，一旦需要提高速度，按需提高令牌产生的速率即可。



## 两种算法的区别

漏桶算法：强制限制了数据的传输速率。`限制的是流出流量`

令牌桶算法：在能够限制数据的平均传输速率以外，还允许某种程度的突发数据流量的传输。`限制的是流入速率`