---
layout: post
title: TCP协议中三次握手和四次握手原理以及TIME_WAIT的真实意义
date: '2018-01-02 14:46'
description: TCP协议中三次握手和四次握手原理
toc: true
tags:
  - TCP
categories:
  - TCP/IP
---

最近遇到了大量TCP连接进入TIME_WAIT状态的情况。索性温习了一下TCP协议原理，从新整理了一下TCP通讯中的三次握手和四次握手流程，以及为什么主动断开连接的一方会进入2倍MSL时间的TIME_WAIT状？

<!--more-->

## socket套接字

Socket（套接字）是支持TCP/IP协议网络通信的基本操作单元。其包含五元组向量<协议，源ip，源端口，目的ip，目的端口>。在应用层传输数据到传输层时，可能存在多个应用程序或者多个TCP连接使用用一个端口的情况，这时候，就需要通过socket套接字来区分这个连接或者应用程序。



## TCP连接的完整过程

### TCP从连接到断开的时序图

![](/images/posts/tcp/tcp.png)



### 连接时的三次握手

- 客户端发起连接请求，建立连接。发送数据包：SYN置1，seq序列号为随机序列值x。随后客户端进入等待服务端确认的状态（SYN_SEND）
- 服务端收到客户端发送的SYN报文，对该SYN报文进行确认。确认后回复报文：SYN置1，ack确认号为x+1，seq序列号为随机生成的序列值y。随后服务端进入SYN_RECV状态
- 客户端收到服务端的确认报文后，客户端也会向服务端发送确认报文：ack确认号为y+1。该确认报文发送完毕后，客户端及进入ESTABLISHED（连接成功）状态。服务端接收后，也会进入ESTABLISHED状态。

三次握手结束之后，客户端和服务端相互确认了对方的可靠，才能正常的进行数据传输。

#### 三次的原因

初始化序列号，并通知对方自己的序列号。保证之后的传输的数据包不会因为网络等问题乱序，以此来建立一个可靠的链接。

- 为了保证服务端能够准确地接收客户端发来的数据信息，并能做出正确的应答而进行的1，2次握手
- 为了保证客户端能够准确地接收服务端返回的数据信息，并能做出正确的应答而进行的2，3次握手
- 第三步的目的其实并不是为了能够接受数据，而是，为了防止服务端程序一直处于等待状态，造成服务端资源的浪费。



### 断开时的四次握手

断开连接的主动方可以是客户端也可以是服务端，这里一客户端主动断开连接为例子。

-  客户端向服务端发送FIN报文并设置seq序列号和ack确认号。客户端进入FIN_WAIT_1状态，表明断开请求报文已经发送，但是还没有收到服务端的确认报文。
-  服务端收到断开请求（FIN报文）。向客户端回复ACK确认报文：ack确认号为收到的seq序列号+1。表示服务端接收客户端的断开请求，发送确认报文，同时服务端进入CLOSE_WAIT状态。客户端收到确认报文后，进入FIN_WAIT_2状态。
-  服务端向客户端发送FIN报文，请求关闭连接，同时服务端进入LAST_ACK状态。
-  客户端收到服务端的FIN报文后，随即TIME_WAIT状态，并向服务端发送ACK确认报文。服务端收到报文后，立刻关闭连接，释放服务端资源。



> 四次握手之后，客户端进入TIME_WAIT状态，服务端在收到客户端发送ACK报文后，立刻关闭连接。此后，客户端进入TIME_WAIT状态2倍MSL（数据包在网络中的生命周期）时间之后，如果一直没有收到服务端的任何回复，则认为与服务端的连接已经正常关闭了，这时，客户端才会关闭连接。




#### 四次的原因

四次握手的主要目的是为了保证客户端和服务端均符合断开连接的条件，且都能够正常的断开连接。TCP是全双工的，断开连接的双方，都需要确认对方是否断开了连接，主动断开连接的一方和被动断开的一方，都需要发送断开请求和断开确认来保证双方都已经断开连接。所以需要上述的四次来保证，整个断开过程是完全、正确的执行。比如，第四次握手，如果没有的话，服务端将不知道它所发送的FIN是否正确送到给了客户端，更不知道，客户端是否断开了连接。


#### TIME_WAIT的作用

主动断开连接的一方，都会进入到TIME_WAIT状态。而主动断开的一方，从TIME_WAIT到CLOSED状态有一个超时时间设置（2倍MSL的时间，Linux设置为30s）。



> 之所以是2倍MSL时间，主要原因有两点：为了让被动断开的一方有足够的时间去接收ACK确认报文，如果没有收到，则重发FIN报文；为了让主动断开的一方有足够的时间不跟其他新的连接混淆。




##### 第四次握手的数据报文没有正常传递

因为没有任何机制能够保证最后一次握手的数据报文能够正确传递到服务端，所以需要等待。如果一直没有到达的话，服务端会再次发送FIN报文（等待时间是2倍MSL的根本原因）。如果客户端直接调用`close()`进入到CLOSED状态，但服务端又没有收到客户端的确认报文，则会重发FIN包，客户端收到后，将会出错。所以客户端需要进入到一个TIME_WAIT的状态，以确定确认报文是否送达，如果没有，则需要接收新的FIN报文，并确认。


##### 网络中任然有可能有残留的数据包

如果网络中的报文，因为网络等问题停留在了网络中成为了网络中的残留数据报文。针对这种情况的存在，TCP连接在完全断开的时候，必须确认网络中已经没有了残留数据包。因为如果客户端不确认这一点，直接在四次握手后断开连接，这些残留数据报文很可能会对之后新建立的连接（复用了相同的端口号）造成很严重的影响。



> 客户端在完全断开连接时，必须确保服务端收到了确认报文，且网络中没有了残留的数据包，否则很可能会对之后的新的连接（复用同一个端口的套接字）产生影响。确认一个数据包以及响应的丢失，当然需要2倍MSL的时间。




